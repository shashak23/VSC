자바스크립트 Java Script 

(( 역사 ))
> 1995년 아이크 브랜든이 개발한 Mocha에서 유래
> 1999년 HTML을 이용한 작업의 문제점 <-> Ajax 등장
> 2006년 jQuery의 등장
> 2009년 구글V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
- ECMAScript의 역사
> 


(( 개념 ))
: 코어(ECMAScript)와 라이브러리 API( Host API , Client-side web API )를 조합한 프로그래밍 언어
: 멀티-패러다임 언어로 명령형, 함수형, 객체 지향형 언어
: 

(( 특징 ))
1. 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다
2. 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어이다
3. 인터프리터와 컴파일러의 장점을 결합해 비교적 처리속도가 느린 인터프린터의 단점을 해결했다
-- 코딩 특징
1. 클래스라는 개념이 없다 : 기존의 객체를 복사해서 새로운 객체를 형성하는 프로토타입 기반의 언어이다
2. 클로저 개념이 있다
3. 클래스와 메소드가 외관으로 구분이 안된다
4. 언제나 Immutability가 보장된다는 점
5. 순수 함수(Pure Function)을 기반으로 코드가 작성되기 때문에 예상치 못한 버그가 최소화된다는 점

(( 단점 ))
1. 언어의 모호성
2. 구현의 어려움
3. Fragmentation : 이건 jQuery를 통해 해결함

*인터프리터 언어
 - 코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간 코드인 바이트코드로 변환한 후 실행한다.
 - 실행 파일을 생성하지 않는다
 - 인터프린터 단계와 실행 단계가 분리되어 있지 않는다
 - 인터프린터는 한 줄씩 바이트코드로 변환하고 즉시 실행한다
 - 코드가 실행될 때마다 인터프리트 과정이 반복 수행된다
 - 인터픠트 단계와 실행 단계가 분리되어 잇지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다


(( Visual Studio Code ))


(( 식별자 Identifier ))
: 어떤 값을 구별해서 식별할 수 있는 고유한 모든 이름
> 식별자는 저장되어 있는 메모리의 값을 구분할 줄 알아야 함
> 근데 그 값은 매핑되늰 메모리의 주소이라서
> 식별자는 값이 아니라 메모리 주소를 기억하고 있다
>> 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다

* 식별자 네이밍 규칙
: 특수문자를 제외한 문자,숫자,언더스코어(_), 달러기호($)
단, 숫자로 시작하는 것은 안된다
(예약어는 식별자로 사용할 수 없다)

(( 변수 선언 Variable Declaration ))
: 변수를 생성하는 것
> 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것
> 변수를 사용하려면 반드시 선언이 필요하다

* 변수를 선언할 때 사용하는 키워드: var, let, const
 - var: 함수 레벨 스코프만 지원함, 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생함
 - let, const: block level scope = 선언을 통해 변수를 생성
 - var와 let의 큰 차이점: 변수를 구분하는 기준에 있는데, (scope)
    - var -> function level scope
    - let -> block level scope
    - 같은 scope내 중복선언 여부: 되는 건 var, 안되는 건 let

★★ 자스에서는 다른데 기본적으로 function level scope를 가져와요 
=> 이말인즉스 자스에서는 함수를 잘 알아야지 잘 이용할 수 있어요!

* 변수 선언 단계
1단계 - 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다
2단계 - 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다

--> 선언한 변수는 어디에 저장되는가?
    : 실행 컨텍스트 

 (( undefined ))
 : 자바스크립트에서 제고하는 원시 타입의 값
 > creation phase에서 생성된 변수의 undefined( 특수한 값 )라는 값이 설정이 되요! 


(( JS의 실행방식 ))
;
- 2페로 실행되기때문에 스코프별로 Hoisting 현상이 발생해요
첫 번째 페이지 -> Creation Phase
두 번째 페이지 -> Execution Phase

(( 값 value ))
: 표현식이 평가되어 생성된 결과를 말한다

(( 리터럴 literal ))
: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
> 종류
 - 100    // 정수리터럴
 - 3.14   // 부동소수점 리터럴
 - 0100   // 2진수 리터럴
 - boolean   // 불리언 리터럴
 - 'hello'   // 문자열 리터럴
 - null   // null 리터럴
 - undefined   // undefined리터럴
 - {  }   // 객체 리터럴
 - function   // 함수 리터럴
 - [1,2,3]    // 배열 리터럴
 
(( 표현식 expression ))
: 값으로 평가될 수 있는 문, 표현식이 평가되면 새로운 값을 생성하거나 기본값을 참조한다
